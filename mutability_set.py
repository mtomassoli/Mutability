from __future__ import annotations
from typing import TYPE_CHECKING, assert_type, Literal as L, Any
from mutability import *

__all__ = ['set_', 'set_out', 'set_r']

if TYPE_CHECKING:
    from typing import (
        overload, Iterable, Iterator, ClassVar, AbstractSet, TypeVar, Generic
    )
    from mutability import Mut_M, Mut_L
    import sys
    if sys.version_info >= (3, 9):
        from types import GenericAlias

    _T = TypeVar('_T')
    
    # NOTE: Don't depend on a lock => can be used anywhere
    type set_out[T, M: (R, W, RK, WK)] = set_[T, M, None]
    type set_r[T] = set_[T, R, Any]

    # NOTE: Self or depend on `_L` => can be used only here
    class _L: ...           # lock
    type _set_in[T, M: (R, W, RK, WK)] = set_[T, M, _L]
    type _Self_W[T] = set_[T, W, _L]
    
    class set_(Generic[_T, Mut_M, Mut_L]):
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, iterable: Iterable[_T], /) -> None: ...
        def __init__(self, *args) -> None: ...
        def add(self: _Self_W[_T], element: _T, /) -> None: ...
        def copy(self) -> set_out[_T, WK]: ...
        def difference(self, *s: Iterable[Any]) -> set_out[_T, WK]: ...
        def difference_update(self: _Self_W[_T], *s: Iterable[Any]) -> None: ...
        def discard(self: _Self_W[_T], element: _T, /) -> None: ...
        def intersection(self, *s: Iterable[Any]) -> set_out[_T, WK]: ...
        def intersection_update(self: _Self_W[_T], *s: Iterable[Any]) -> None: ...
        def isdisjoint(self, s: Iterable[Any], /) -> bool: ...
        def issubset(self, s: Iterable[Any], /) -> bool: ...
        def issuperset(self, s: Iterable[Any], /) -> bool: ...
        def remove(self: _Self_W[_T], element: _T, /) -> None: ...
        def symmetric_difference(self, s: Iterable[_T], /) -> set_out[_T, WK]: ...
        def symmetric_difference_update(self: _Self_W[_T], s: Iterable[_T], /
                                        ) -> None: ...
        def union[S](self, *s: Iterable[S]) -> set_out[_T | S, WK]: ...
        def update(self:_Self_W[_T], *s: Iterable[_T]) -> None: ...
        def __len__(self) -> int: ...
        def __contains__(self, o: object, /) -> bool: ...
        def __iter__(self) -> Iterator[_T]: ...
        def __and__(self, value: AbstractSet[object], /) -> set_out[_T, WK]: ...
        def __iand__(self: _Self_W[_T], value: AbstractSet[object], /
                     ) -> set_[_T, Mut_M, Mut_L]: ...
        def __or__[S](self, value: AbstractSet[S], /) -> set[_T | S]: ...
        def __ior__(self: _Self_W[_T], value: AbstractSet[_T], /
                    ) -> set_[_T, Mut_M, Mut_L]: ...
        def __sub__(self, value: AbstractSet[_T | None], /) -> set[_T]: ...
        def __isub__(self: _Self_W[_T], value: AbstractSet[object], /
                     ) -> set_[_T, Mut_M, Mut_L]: ...
        def __xor__[S](self, value: AbstractSet[S], /) -> set[_T | S]: ...
        def __ixor__(self: _Self_W[_T], value: AbstractSet[_T], /
                     ) -> set_[_T, Mut_M, Mut_L]: ...
        def __le__(self, value: AbstractSet[object], /) -> bool: ...
        def __lt__(self, value: AbstractSet[object], /) -> bool: ...
        def __ge__(self, value: AbstractSet[object], /) -> bool: ...
        def __gt__(self, value: AbstractSet[object], /) -> bool: ...
        def __eq__(self, value: object, /) -> bool: ...
        __hash__: ClassVar[None]  # type: ignore[assignment]
        if sys.version_info >= (3, 9):
            def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
else:
    set_ = set_out = set_r = set

if __name__ == "__main__":
    a = lift(set([1, 2, 3]))
    a_r = r(a)
    a_w = w(a)
    a_rk = rk(a)
    a_wk = wk(a)

    assert_type(r(a_r), set_[int, R, Any])
    assert_type(r(a_w), set_[int, R, Any])
    assert_type(r(a_rk), set_[int, R, Any])
    assert_type(r(a_wk), set_[int, R, Any])

    _ = w(a_r)     # pyright: ignore
    assert_type(w(a_w), set_[int, W, Any])
    _ = w(a_rk)    # pyright: ignore
    assert_type(w(a_wk), set_[int, W, Any])

    _ = rk(a_r)    # pyright: ignore
    _ = rk(a_w)    # pyright: ignore
    assert_type(rk(a_rk), set_[int, RK, Any])
    assert_type(rk(a_wk), set_[int, RK, Any])

    _ = wk(a_r)    # pyright: ignore
    _ = wk(a_w)    # pyright: ignore
    _ = wk(a_rk)   # pyright: ignore
    assert_type(wk(a_wk), set_[int, WK, Any])

    def f_r(a: set_[int, R, Any]) -> L[0]: ...
    def f_w(a: set_[int, W, None]) -> L[0]: ...
    def f_rk(a: set_[int, RK, None]) -> L[0]: ...
    def f_wk(a: set_[int, WK, None]) -> L[0]: ...

    assert_type((f_r(a_r), f_r(a_w), f_r(a_rk), f_r(a_wk)),
                tuple[L[0], L[0], L[0], L[0]])

    _ = f_w(a_r)    # pyright: ignore
    assert_type(f_w(a_w), L[0])
    _ = f_w(a_rk)   # pyright: ignore
    assert_type(f_w(a_wk), L[0])

    _ = f_rk(a_r)   # pyright: ignore
    _ = f_rk(a_w)   # pyright: ignore
    assert_type(f_rk(a_rk), L[0])
    assert_type(f_rk(a_wk), L[0])

    _ = f_wk(a_r)   # pyright: ignore
    _ = f_wk(a_w)   # pyright: ignore
    _ = f_wk(a_rk)  # pyright: ignore
    assert_type(f_wk(a_wk), L[0])
